-- Телепортируемся к точке
game.Workspace.Map["1 | Spawn"].PARTS.Model.Mining.Enter.CFrame = CFrame.new(game.Workspace.Map["1 | Spawn"].PARTS.Model.Mining.Enter.Position)
wait(4)  -- Ждем 4 секунды

-- Отправляем запрос на телепортацию
local args = {
    [1] = "__Zone_5"
}
game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Teleports_RequestInstanceTeleport"):InvokeServer(unpack(args))
wait(4)  -- Ждем 4 секунды

loadstring(game:HttpGet("https://raw.githubusercontent.com/San1na/Ozzi/refs/heads/main/Auto"))()
wait(10)  -- Подождать 10 секунд

-- Координаты для создания платформ
local coordinates = {
    Vector3.new(11901.12, 0, -4051.13),
    Vector3.new(11948.33, 0, -4052.46),
    Vector3.new(11990.36, 0, -4053.17),
    Vector3.new(12033.63, 0, -4053.67),
    Vector3.new(12033.97, 0, -4012.31),
    Vector3.new(11967.63, 0, -4011.10),
    Vector3.new(11924.60, 0, -4010.83),
    Vector3.new(11893.19, 0, -4009.65),
    Vector3.new(11895.53, 0, -3962.92),
    Vector3.new(11954.54, 0, -3966.27),
    Vector3.new(12000.34, 0, -3967.18),
    Vector3.new(12040.04, 0, -3966.48),
    Vector3.new(12040.63, 0, -3925.32),
    Vector3.new(11985.83, 0, -3923.77),
    Vector3.new(11930.95, 0, -3924.34),
    Vector3.new(11894.52, 0, -3924.32)
}

local partCounter = 1  -- Счетчик для именования платформ

-- Флаг автофермы
local autoFarmActive = true

-- Создаем платформы на каждой координате
for _, coord in ipairs(coordinates) do
    -- Если автоферма выключена, прерываем выполнение
    if not autoFarmActive then break end

    -- Создаем платформу на данной позиции
    local platform = Instance.new("Part")
    platform.Size = Vector3.new(10, 1, 10)  -- Размер платформы
    platform.Position = coord  -- Позиция платформы
    platform.Anchored = true  -- Закрепляем платформу
    platform.Name = "part" .. partCounter  -- Уникальное имя платформы
    platform.Parent = game.Workspace  -- Добавляем платформу в мир

    -- Добавляем платформы для каждой высоты кратной 35 до -620
    for y = math.floor(coord.Y / 35) * 35, -620, -35 do
        if not autoFarmActive then break end  -- Проверяем флаг

        local additionalPlatform = platform:Clone()
        additionalPlatform.Position = Vector3.new(coord.X, y, coord.Z)
        additionalPlatform.Name = "part" .. partCounter  -- Уникальное имя для клонированной платформы
        additionalPlatform.Parent = game.Workspace
        partCounter = partCounter + 1  -- Увеличиваем счетчик для следующей платформы
    end

    partCounter = partCounter + 1  -- Увеличиваем счетчик для основной платформы
end

wait(3)  -- Подождать 3 секунды

-- Устанавливаем состояние флага в зависимости от состояния тумблера
local tpActive = true  -- или state, в зависимости от вашего кода

local player = game.Players.LocalPlayer  -- Получаем текущего игрока
local startPartIndex = 1  -- Начальный индекс для платформ
local endPartIndex = 1000  -- Конечный индекс платформ

-- Функция для телепортации игрока к указанной платформе
local function teleportToPart(partName)
    local part = game.Workspace:FindFirstChild(partName)
    if part then
        player.Character.HumanoidRootPart.CFrame = part.CFrame  -- Телепортируем игрока к найденной платформе
    else
        warn("Платформа " .. partName .. " не найдена!")
    end
end

-- Цикл, который будет телепортировать игрока к платформам с названиями от part1 до part1000
while tpActive do
    for i = startPartIndex, endPartIndex do
        if not tpActive then break end  -- Если тумблер выключен, прерываем цикл

        local partName = "part" .. i  -- Формируем имя платформы
        teleportToPart(partName)  -- Телепортируем к платформе
        wait(0.65)  -- Задержка между телепортациями (по желанию можно изменить)
    end
    -- Если цикл завершился, начинаем сначала
    if tpActive then
        wait(1)  -- Добавляем небольшую задержку перед новым циклом
    end
end

-- Таймер на 3 с половиной минуты перед сервер-хопом
wait(3 * 60 + 30)  -- Подождать 3 минуты 30 секунд

local function serverHop()
    local servers = {}
    local url = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Asc&limit=100"

    local success, result = pcall(function()
        return HttpService:GetAsync(url)  -- Используем GetAsync вместо HttpGet
    end)

    if success then
        local data = HttpService:JSONDecode(result)
        for _, server in pairs(data.data) do
            -- Если сервер не полный и это не тот сервер, на котором игрок уже находится
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server.id)
            end
        end
        if #servers > 0 then
            -- Телепортируем на случайный сервер из найденных
            local selectedServer = servers[math.random(1, #servers)]
            TeleportService:TeleportToPlaceInstance(gameId, selectedServer, player)
        else
            warn("Не найдено подходящих серверов")
        end
    else
        warn("Ошибка получения данных о серверах: " .. result)  -- Логируем ошибку
    end
end

-- Выполняем сервер-хоп
serverHop()
